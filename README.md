# GPU-Native OS

A single-threadgroup operating system running entirely on the GPU via Metal compute shaders.

## Overview

This project explores a radical approach to application architecture: instead of the CPU orchestrating rendering with GPU assistance, **the GPU runs the entire application** — input handling, state updates, layout, and rendering — in a single compute kernel per frame.

All 1024 threads participate in every phase. The CPU's role is minimal: forward input events and submit command buffers.

## GpuApp Framework

The `GpuApp` trait provides a standardized way to build GPU-native applications. Apps implement this trait and run on the `GpuRuntime`, which manages:

- **Input handling** — Keyboard/mouse events forwarded to GPU
- **Memory management** — Unified CPU/GPU buffers
- **Frame timing** — Delta time, frame counting
- **Render pipeline** — Compute → Render → Present

```rust
pub trait GpuApp {
    fn name(&self) -> &str;
    fn compute_pipeline(&self) -> &ComputePipelineState;
    fn render_pipeline(&self) -> &RenderPipelineState;
    fn vertices_buffer(&self) -> &Buffer;
    fn vertex_count(&self) -> usize;
    fn app_buffers(&self) -> Vec<&Buffer>;
    fn params_buffer(&self) -> &Buffer;
    fn update_params(&mut self, frame_state: &FrameState, delta_time: f32);
    fn handle_input(&mut self, event: &InputEvent);
}
```

### Buffer Slot Convention

All apps follow a standardized buffer binding:

| Slot | Buffer | Purpose |
|------|--------|---------|
| 0 | FrameState | OS-provided: cursor, time, frame number |
| 1 | InputQueue | OS-provided: keyboard/mouse events |
| 2 | AppParams | App-specific per-frame parameters |
| 3+ | App buffers | App-specific state |

### Frame Execution

Each frame, `GpuRuntime` executes:

```
1. Update timing (delta_time, frame_count)
2. Process input events → forward to app
3. App updates params buffer
4. COMPUTE PASS: dispatch app kernel (1024 threads)
5. RENDER PASS: draw vertices generated by compute
6. Present drawable
```

## Demo Applications

### Game of Life

Conway's Game of Life running entirely on GPU. The compute kernel:
- Updates cell state (alive/dead) based on neighbor count
- Generates colored quads for each living cell
- All 1024 threads process cells in parallel

```bash
cargo run --example game_of_life
```

**Controls:** Click to toggle cells, watch patterns evolve.

### Text Editor

A complete text editor running on the GPU. Features:
- Document buffer in unified memory (64K chars max)
- GPU-computed line layout and cursor positioning
- 5x7 bitmap font rendered in fragment shader
- Parallel character shifting for O(1) insert/delete

```bash
cargo run --example text_editor
```

**Controls:**
- Type to insert characters
- Arrow keys to move cursor
- Backspace/Delete to remove characters
- Enter for newlines
- Home/End for line navigation

### Ball Physics (Legacy)

1024-ball physics simulation with collision detection.

```bash
cargo run --example ball_physics
```

## Architecture

```
┌──────────────────────────────────────────────────────────────┐
│                        CPU (minimal)                         │
├──────────────────────────────────────────────────────────────┤
│  macOS events → InputHandler → [shared buffer]               │
│  GpuRuntime.run_frame() → compute → render → present         │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                   GPU (1024 threads, 1 threadgroup)          │
├──────────────────────────────────────────────────────────────┤
│  App Compute Kernel:                                         │
│    Phase 1: Process pending edits/input                      │
│    Phase 2: Update state (cells, document, physics)          │
│    Phase 3: Generate vertex geometry                         │
│                                                              │
│  Render Pass:                                                │
│    Vertex Shader → Fragment Shader → Pixels                  │
└──────────────────────────────────────────────────────────────┘
```

## Why?

**Apple Silicon unified memory** eliminates CPU↔GPU copies. App state lives in shared buffers accessible to both. The GPU reads input, processes state, and renders — all without round-trips.

**Single threadgroup** means all 1024 threads share 32KB of fast threadgroup memory. They can synchronize with barriers and use SIMD operations for parallel reductions.

**Branchless SIMD** keeps all threads executing the same instructions, avoiding warp divergence that kills GPU performance.

## Requirements

- macOS with Apple Silicon (M1/M2/M3/M4) or AMD GPU
- Rust 1.70+
- Xcode Command Line Tools (for Metal compiler)

## Quick Start

```bash
# Build all examples
cargo build --release

# Run demos
cargo run --example game_of_life --release
cargo run --example text_editor --release
cargo run --example ball_physics --release

# Run tests
cargo test
```

## Project Structure

```
src/
├── lib.rs                    # Library entry
└── gpu_os/
    ├── mod.rs                # Module exports
    ├── app.rs                # GpuApp trait + GpuRuntime
    ├── kernel.rs             # Compute kernel management
    ├── memory.rs             # GPU buffer allocation
    ├── input.rs              # Input event handling
    ├── layout.rs             # Constraint-based layout
    ├── widget.rs             # Widget state & types
    ├── text.rs               # Text rendering
    ├── render.rs             # Hybrid compute+fragment pipeline
    ├── vsync.rs              # Frame timing & sync
    ├── game_of_life.rs       # Game of Life app
    ├── text_editor.rs        # Text Editor app
    └── ball_physics.rs       # Ball Physics demo

examples/
├── game_of_life.rs           # Game of Life demo runner
├── text_editor.rs            # Text Editor demo runner
├── ball_physics.rs           # Ball Physics demo runner
└── gpu_os_demo.rs            # Legacy OS demo

docs/
├── GPU_NATIVE_OS_V2_PRD.md   # OS design document
└── TEXT_EDITOR_PRD.md        # Text editor design
```

## Creating a New App

1. Create `src/gpu_os/my_app.rs` implementing `GpuApp`
2. Define your compute kernel using `APP_SHADER_HEADER`
3. Create buffers for your app state
4. Implement `update_params()` and `handle_input()`
5. Create `examples/my_app.rs` to run it with `GpuRuntime`

Example skeleton:

```rust
use super::app::{GpuApp, AppBuilder, APP_SHADER_HEADER};

pub struct MyApp {
    compute_pipeline: ComputePipelineState,
    render_pipeline: RenderPipelineState,
    // ... your buffers
}

impl GpuApp for MyApp {
    fn name(&self) -> &str { "My App" }
    // ... implement trait methods
}
```

## Performance

| Metric | Target |
|--------|--------|
| Frame time | < 8ms (120 FPS) |
| Compute dispatch | < 1ms |
| Input latency | 1 frame |
| Memory | Unified (no copies) |

## License

MIT

## Acknowledgments

Inspired by Casey Muratori's discussions on GPU-driven UI and Apple's TBDR (Tile-Based Deferred Rendering) architecture.
