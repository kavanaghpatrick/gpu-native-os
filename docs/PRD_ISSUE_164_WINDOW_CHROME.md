# PRD: Window Chrome as Megakernel App (Issue #164)

## Overview

Window decorations (title bar, buttons, borders, resize handles) become a system app that runs alongside user apps. Each window's chrome is generated by the chrome app based on window state.

## Infrastructure Used

| Need | Infrastructure | File |
|------|---------------|------|
| Window drag/resize | GPU event dispatch | `event_loop.rs` |
| Hit regions | HIT_TEST dispatch | `event_loop.rs` |
| Button rendering | Hybrid render | `render.rs` |
| Title text | Bitmap font | `text_render.rs` |

## GPU-Native Principles

| CPU Pattern (Wrong) | GPU Pattern (Right) |
|---------------------|---------------------|
| CPU draws each window's chrome | GPU generates all chrome in parallel |
| Per-window title bar logic | Chrome app reads window array |
| CPU hit-tests buttons | `event_loop.rs` GPU hit-test |
| Separate chrome renderer | Writes to unified vertex buffer |

## The GPU Insight

Window chrome is just geometry. The chrome app reads the window array and generates vertices for all windows in parallel:

```metal
// Each thread handles one window's chrome
uint window_idx = tid;
if (window_idx < window_count) {
    generate_window_chrome(windows[window_idx], verts + window_idx * CHROME_VERTS_PER_WINDOW);
}
```

## Design

### Chrome State Structure

```metal
struct WindowChromeState {
    uint window_count;
    uint focused_window;
    uint dragging_window;      // Window being dragged
    uint resizing_window;      // Window being resized
    uint hovered_button;       // Which button is hovered (encoded: window << 8 | button)
    uint clicked_button;       // Which button was clicked
    float2 drag_offset;        // Offset from window origin to mouse
    float2 resize_origin;      // Original window size for resize

    // Chrome dimensions
    float title_bar_height;
    float border_width;
    float button_size;
    float corner_radius;

    // Colors
    float4 title_focused;
    float4 title_unfocused;
    float4 close_color;
    float4 minimize_color;
    float4 maximize_color;
    float4 border_color;
};

// Button indices
constant uint BUTTON_CLOSE = 0;
constant uint BUTTON_MINIMIZE = 1;
constant uint BUTTON_MAXIMIZE = 2;
constant uint BUTTON_NONE = 255;
```

### Chrome Update Function

```metal
inline void window_chrome_update(
    device GpuAppDescriptor* app,
    device uchar* unified_state,
    device RenderVertex* unified_vertices,
    device GpuWindow* windows,
    uint window_count,
    uint tid,
    uint tg_size
) {
    device WindowChromeState* state = (device WindowChromeState*)(unified_state + app->state_offset);

    // Each thread generates chrome for one window
    if (tid >= window_count) {
        if (tid == 0) app->vertex_count = 0;
        return;
    }

    GpuWindow window = windows[tid];
    if (!(window.flags & WINDOW_VISIBLE)) return;

    device RenderVertex* verts = unified_vertices + (app->vertex_offset / sizeof(RenderVertex));
    uint base = tid * CHROME_VERTS_PER_WINDOW;

    bool is_focused = (tid == state->focused_window);
    float4 title_color = is_focused ? state->title_focused : state->title_unfocused;
    float depth = window.depth + 0.001;  // Chrome slightly in front of content

    uint vert_count = 0;

    // Title bar background
    write_quad(verts + base + vert_count,
        float2(window.x, window.y - state->title_bar_height),
        float2(window.width, state->title_bar_height),
        depth, title_color);
    vert_count += 6;

    // Close button (red circle)
    float btn_y = window.y - state->title_bar_height / 2.0;
    float btn_x = window.x + 12.0;

    write_circle(verts + base + vert_count,
        float2(btn_x, btn_y),
        state->button_size / 2.0,
        depth, state->close_color);
    vert_count += 18;  // Circle uses 18 vertices (6 triangles)

    // Minimize button (yellow)
    btn_x += state->button_size + 8.0;
    write_circle(verts + base + vert_count,
        float2(btn_x, btn_y),
        state->button_size / 2.0,
        depth, state->minimize_color);
    vert_count += 18;

    // Maximize button (green)
    btn_x += state->button_size + 8.0;
    write_circle(verts + base + vert_count,
        float2(btn_x, btn_y),
        state->button_size / 2.0,
        depth, state->maximize_color);
    vert_count += 18;

    // Border (4 quads)
    // Left
    write_quad(verts + base + vert_count,
        float2(window.x - state->border_width, window.y - state->title_bar_height),
        float2(state->border_width, window.height + state->title_bar_height),
        depth, state->border_color);
    vert_count += 6;

    // Right
    write_quad(verts + base + vert_count,
        float2(window.x + window.width, window.y - state->title_bar_height),
        float2(state->border_width, window.height + state->title_bar_height),
        depth, state->border_color);
    vert_count += 6;

    // Bottom
    write_quad(verts + base + vert_count,
        float2(window.x - state->border_width, window.y + window.height),
        float2(window.width + state->border_width * 2.0, state->border_width),
        depth, state->border_color);
    vert_count += 6;

    // Resize handle (bottom-right corner)
    write_quad(verts + base + vert_count,
        float2(window.x + window.width - 16.0, window.y + window.height - 16.0),
        float2(16.0, 16.0),
        depth, float4(0.5, 0.5, 0.5, 0.5));
    vert_count += 6;

    // Thread 0 updates total vertex count
    if (tid == 0) {
        app->vertex_count = window_count * CHROME_VERTS_PER_WINDOW;
    }
}

constant uint CHROME_VERTS_PER_WINDOW = 6 + 18*3 + 6*4;  // Title + 3 buttons + 4 borders
```

### Window Dragging

```metal
inline void process_chrome_input(
    device WindowChromeState* state,
    device GpuWindow* windows,
    InputEvent event,
    uint window_count
) {
    if (event.event_type == EVENT_MOUSE_DOWN) {
        // Check each window's title bar
        for (uint i = 0; i < window_count; i++) {
            GpuWindow w = windows[i];
            if (!(w.flags & WINDOW_VISIBLE)) continue;

            // Title bar bounds
            float title_top = w.y - state->title_bar_height;
            if (event.position.x >= w.x && event.position.x < w.x + w.width &&
                event.position.y >= title_top && event.position.y < w.y) {

                // Check buttons first
                float btn_x = w.x + 12.0;
                float btn_y = title_top + state->title_bar_height / 2.0;

                if (distance(event.position, float2(btn_x, btn_y)) < state->button_size) {
                    state->clicked_button = (i << 8) | BUTTON_CLOSE;
                    return;
                }
                btn_x += state->button_size + 8.0;
                if (distance(event.position, float2(btn_x, btn_y)) < state->button_size) {
                    state->clicked_button = (i << 8) | BUTTON_MINIMIZE;
                    return;
                }
                btn_x += state->button_size + 8.0;
                if (distance(event.position, float2(btn_x, btn_y)) < state->button_size) {
                    state->clicked_button = (i << 8) | BUTTON_MAXIMIZE;
                    return;
                }

                // Start dragging
                state->dragging_window = i;
                state->drag_offset = event.position - float2(w.x, w.y);
                return;
            }

            // Check resize handle
            if (event.position.x >= w.x + w.width - 16.0 &&
                event.position.y >= w.y + w.height - 16.0) {
                state->resizing_window = i;
                state->resize_origin = float2(w.width, w.height);
                return;
            }
        }
    } else if (event.event_type == EVENT_MOUSE_MOVE) {
        if (state->dragging_window != UINT_MAX) {
            windows[state->dragging_window].x = event.position.x - state->drag_offset.x;
            windows[state->dragging_window].y = event.position.y - state->drag_offset.y;
        }
        if (state->resizing_window != UINT_MAX) {
            // Resize logic
        }
    } else if (event.event_type == EVENT_MOUSE_UP) {
        state->dragging_window = UINT_MAX;
        state->resizing_window = UINT_MAX;
    }
}
```

### Rust Integration

```rust
impl GpuOs {
    /// Handle chrome button clicks
    pub fn process_chrome_actions(&mut self) {
        let state = self.get_chrome_state();

        if state.clicked_button != u32::MAX {
            let window_idx = (state.clicked_button >> 8) as u32;
            let button = (state.clicked_button & 0xFF) as u32;

            match button {
                BUTTON_CLOSE => self.close_window(window_idx),
                BUTTON_MINIMIZE => self.minimize_window(window_idx),
                BUTTON_MAXIMIZE => self.maximize_window(window_idx),
                _ => {}
            }

            // Clear clicked state
            self.get_chrome_state_mut().clicked_button = u32::MAX;
        }
    }
}
```

## Tests

```rust
#[test]
fn test_chrome_generates_vertices() {
    let device = get_device();
    let mut os = GpuOs::boot(&device).unwrap();

    os.launch_app(app_type::TERMINAL);

    os.system.run_frame();
    os.system.finalize_render();

    // Chrome app should have generated vertices
    let chrome = os.system.get_app(os.chrome_slot).unwrap();
    assert!(chrome.vertex_count > 0);
}

#[test]
fn test_window_dragging() {
    let device = get_device();
    let mut os = GpuOs::boot(&device).unwrap();

    let app = os.launch_app(app_type::TERMINAL).unwrap();
    let initial_x = os.system.get_window(app).unwrap().x;

    // Mouse down on title bar
    os.system.queue_input(InputEvent::mouse_down(initial_x + 50.0, 10.0, 0));
    os.system.process_input();

    // Drag
    os.system.queue_input(InputEvent::mouse_move(initial_x + 150.0, 10.0));
    os.system.process_input();
    os.system.run_frame();

    // Window should have moved
    let new_x = os.system.get_window(app).unwrap().x;
    assert!(new_x > initial_x);
}

#[test]
fn test_close_button() {
    let device = get_device();
    let mut os = GpuOs::boot(&device).unwrap();

    let app = os.launch_app(app_type::TERMINAL).unwrap();
    let window = os.system.get_window(app).unwrap();

    // Click close button
    os.system.queue_input(InputEvent::mouse_click(window.x + 12.0, window.y - 12.0, 0));
    os.system.process_input();
    os.system.run_frame();
    os.process_chrome_actions();

    // App should be closed
    assert!(os.system.get_app(app).is_none());
}
```

## Benchmarks

```rust
#[test]
fn bench_chrome_20_windows() {
    let device = get_device();
    let mut os = GpuOs::boot(&device).unwrap();

    for _ in 0..20 {
        os.launch_app(app_type::TERMINAL);
    }

    let start = Instant::now();
    for _ in 0..1000 {
        os.system.mark_all_dirty();
        os.system.run_frame();
    }
    let duration = start.elapsed();

    println!("Chrome (20 windows): {}us/frame", duration.as_micros() / 1000);
}
```

## Success Metrics

1. **Parallel generation**: All window chrome generated simultaneously
2. **Smooth dragging**: 60 FPS during window drag
3. **Button response**: < 16ms from click to visual feedback
4. **No CPU per window**: Chrome generated entirely on GPU
