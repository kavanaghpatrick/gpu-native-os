//! SDF Atlas Generator
//!
//! Generates a pre-baked SDF atlas from a system font.
//! Run once to create embedded data for the library.
//!
//! Usage: cargo run --release --example generate_sdf_atlas
//!
//! Outputs:
//!   src/gpu_os/sdf_text/atlas_data.rs - Embedded atlas and metrics

use rust_experiment::gpu_os::sdf_text::{PathSegment, SdfFont};
use std::fs::File;
use std::io::Write;

const SDF_SIZE: u32 = 48;        // Pixels per glyph SDF
const ATLAS_COLS: u32 = 10;      // Glyphs per row
const ATLAS_ROWS: u32 = 10;      // Rows in atlas
const PADDING: u32 = 2;          // Padding between glyphs
const SPREAD: f32 = 8.0;         // SDF spread in pixels

fn main() {
    println!("===========================================");
    println!("  SDF Atlas Generator");
    println!("===========================================\n");

    // Load system font
    println!("Loading system font...");
    let font = SdfFont::load_default().expect("Failed to load system font");
    println!("  Units per EM: {}", font.units_per_em());
    println!("  Cached glyphs: {}", font.cached_glyph_count());

    let units_per_em = font.units_per_em() as f32;

    // Collect all ASCII glyphs (32-126)
    let ascii_chars: Vec<char> = (32u8..=126).map(|c| c as char).collect();
    let glyph_count = ascii_chars.len();

    println!("\nProcessing {} glyphs...", glyph_count);

    // Calculate atlas dimensions
    let atlas_width = ATLAS_COLS * (SDF_SIZE + PADDING);
    let atlas_height = ATLAS_ROWS * (SDF_SIZE + PADDING);
    let atlas_size = (atlas_width * atlas_height) as usize;

    println!("  Atlas size: {}x{}", atlas_width, atlas_height);

    // Create atlas buffer
    let mut atlas: Vec<f32> = vec![0.5; atlas_size]; // 0.5 = edge (neutral)
    let mut glyph_metrics: Vec<GlyphMetric> = Vec::new();

    // Process each glyph
    for (idx, &c) in ascii_chars.iter().enumerate() {
        let col = idx as u32 % ATLAS_COLS;
        let row = idx as u32 / ATLAS_COLS;
        let atlas_x = col * (SDF_SIZE + PADDING);
        let atlas_y = row * (SDF_SIZE + PADDING);

        let advance = font.glyph_advance(c).unwrap_or(units_per_em * 0.25);

        if let Some(outline) = font.glyph_outline(c) {
            if !outline.is_empty() {
                let bounds = &outline.bounds;

                // Generate SDF for this glyph
                generate_glyph_sdf(
                    &mut atlas,
                    atlas_width,
                    atlas_x,
                    atlas_y,
                    SDF_SIZE,
                    &outline.segments,
                    bounds.x_min,
                    bounds.y_min,
                    bounds.x_max,
                    bounds.y_max,
                    SPREAD,
                );

                glyph_metrics.push(GlyphMetric {
                    advance,
                    bounds: [bounds.x_min, bounds.y_min, bounds.x_max, bounds.y_max],
                    atlas_x,
                    atlas_y,
                });
            } else {
                // Empty outline (like space)
                glyph_metrics.push(GlyphMetric {
                    advance,
                    bounds: [0.0, 0.0, advance, units_per_em],
                    atlas_x,
                    atlas_y,
                });
            }
        } else {
            // No glyph
            glyph_metrics.push(GlyphMetric {
                advance,
                bounds: [0.0, 0.0, advance, units_per_em],
                atlas_x,
                atlas_y,
            });
        }

        // Progress indicator
        if (idx + 1) % 10 == 0 {
            print!(".");
            std::io::stdout().flush().unwrap();
        }
    }
    println!(" Done!");

    // Convert to u8
    let atlas_u8: Vec<u8> = atlas.iter().map(|&v| (v.clamp(0.0, 1.0) * 255.0) as u8).collect();

    // Generate Rust source file with embedded data
    println!("\nGenerating embedded atlas data...");

    let mut output = String::new();
    output.push_str("// AUTO-GENERATED - Do not edit manually\n");
    output.push_str("// Generated by: cargo run --release --example generate_sdf_atlas\n\n");

    output.push_str(&format!("pub const SDF_SIZE: u32 = {};\n", SDF_SIZE));
    output.push_str(&format!("pub const ATLAS_WIDTH: u32 = {};\n", atlas_width));
    output.push_str(&format!("pub const ATLAS_HEIGHT: u32 = {};\n", atlas_height));
    output.push_str(&format!("pub const ATLAS_COLS: u32 = {};\n", ATLAS_COLS));
    output.push_str(&format!("pub const PADDING: u32 = {};\n", PADDING));
    output.push_str(&format!("pub const SPREAD: f32 = {:.1};\n", SPREAD));
    output.push_str(&format!("pub const UNITS_PER_EM: f32 = {:.1};\n", units_per_em));
    output.push_str(&format!("pub const ASCENDER: f32 = {:.1};\n", font.ascender() as f32));
    output.push_str(&format!("pub const DESCENDER: f32 = {:.1};\n", font.descender() as f32));
    output.push_str(&format!("pub const LINE_HEIGHT: f32 = {:.1};\n\n", font.line_height() as f32));

    // Glyph metrics struct
    output.push_str("#[repr(C)]\n");
    output.push_str("#[derive(Clone, Copy)]\n");
    output.push_str("pub struct GlyphMetric {\n");
    output.push_str("    pub advance: f32,\n");
    output.push_str("    pub bounds: [f32; 4],\n");
    output.push_str("    pub atlas_x: u32,\n");
    output.push_str("    pub atlas_y: u32,\n");
    output.push_str("}\n\n");

    output.push_str(&format!("pub const GLYPH_METRICS: [GlyphMetric; {}] = [\n", glyph_count));
    for (idx, metric) in glyph_metrics.iter().enumerate() {
        let c = ascii_chars[idx];
        let c_escaped = match c {
            '\'' => "\\'".to_string(),
            '\\' => "\\\\".to_string(),
            _ => c.to_string(),
        };
        output.push_str(&format!(
            "    GlyphMetric {{ advance: {:.1}, bounds: [{:.1}, {:.1}, {:.1}, {:.1}], atlas_x: {}, atlas_y: {} }}, // '{}'\n",
            metric.advance, metric.bounds[0], metric.bounds[1], metric.bounds[2], metric.bounds[3],
            metric.atlas_x, metric.atlas_y, c_escaped
        ));
    }
    output.push_str("];\n\n");

    // Atlas data as bytes
    output.push_str(&format!("pub const ATLAS_DATA: [u8; {}] = [\n", atlas_u8.len()));
    for chunk in atlas_u8.chunks(32) {
        output.push_str("    ");
        for byte in chunk {
            output.push_str(&format!("{:#04x}, ", byte));
        }
        output.push('\n');
    }
    output.push_str("];\n");

    // Write to file
    let output_path = "src/gpu_os/sdf_text/atlas_data.rs";
    let mut file = File::create(output_path).expect("Failed to create output file");
    file.write_all(output.as_bytes()).expect("Failed to write output");

    println!("  Written: {}", output_path);
    println!("  Atlas data: {} bytes", atlas_u8.len());

    // Save debug image
    println!("\nSaving debug image...");
    save_debug_pgm(&atlas_u8, atlas_width, atlas_height);

    println!("\n===========================================");
    println!("  SDF Atlas Generation Complete!");
    println!("===========================================");
}

#[derive(Clone, Copy)]
struct GlyphMetric {
    advance: f32,
    bounds: [f32; 4],
    atlas_x: u32,
    atlas_y: u32,
}

fn generate_glyph_sdf(
    atlas: &mut [f32],
    atlas_width: u32,
    atlas_x: u32,
    atlas_y: u32,
    sdf_size: u32,
    segments: &[PathSegment],
    x_min: f32,
    y_min: f32,
    x_max: f32,
    y_max: f32,
    spread: f32,
) {
    let glyph_width = x_max - x_min;
    let glyph_height = y_max - y_min;

    if glyph_width <= 0.0 || glyph_height <= 0.0 {
        return;
    }

    // Scale factor to fit glyph in SDF with padding
    let pad = spread * 2.0;
    let scale = (sdf_size as f32 - 4.0) / (glyph_width.max(glyph_height) + pad);
    let center_x = (x_min + x_max) * 0.5;
    let center_y = (y_min + y_max) * 0.5;

    // Flatten path segments to line segments for easier processing
    let lines = flatten_path(segments);

    for py in 0..sdf_size {
        for px in 0..sdf_size {
            // Map pixel to glyph coordinate space
            let gx = center_x + (px as f32 - sdf_size as f32 * 0.5) / scale;
            let gy = center_y + (py as f32 - sdf_size as f32 * 0.5) / scale;

            // Find minimum distance to all line segments
            let mut min_dist = f32::MAX;
            for (p1, p2) in &lines {
                let d = distance_to_line_segment(gx, gy, p1.0, p1.1, p2.0, p2.1);
                min_dist = min_dist.min(d);
            }

            // Determine inside/outside using winding number
            let winding = compute_winding_number(gx, gy, &lines);
            let inside = winding != 0;

            // Apply sign
            let signed_dist = if inside { -min_dist } else { min_dist };

            // Normalize to 0-1 range
            let normalized = (signed_dist / spread) * 0.5 + 0.5;

            // Write to atlas
            let ax = atlas_x + px;
            let ay = atlas_y + py;
            let idx = (ay * atlas_width + ax) as usize;
            if idx < atlas.len() {
                atlas[idx] = normalized;
            }
        }
    }
}

fn flatten_path(segments: &[PathSegment]) -> Vec<((f32, f32), (f32, f32))> {
    let mut lines = Vec::new();
    let mut current = (0.0f32, 0.0f32);
    let mut path_start = (0.0f32, 0.0f32);

    for seg in segments {
        match seg {
            PathSegment::MoveTo(x, y) => {
                current = (*x, *y);
                path_start = current;
            }
            PathSegment::LineTo(x, y) => {
                lines.push((current, (*x, *y)));
                current = (*x, *y);
            }
            PathSegment::QuadTo(cx, cy, x, y) => {
                // Flatten quadratic bezier to line segments
                let steps = 8;
                for i in 0..steps {
                    let t0 = i as f32 / steps as f32;
                    let t1 = (i + 1) as f32 / steps as f32;

                    let p0 = eval_quad(current.0, current.1, *cx, *cy, *x, *y, t0);
                    let p1 = eval_quad(current.0, current.1, *cx, *cy, *x, *y, t1);
                    lines.push((p0, p1));
                }
                current = (*x, *y);
            }
            PathSegment::CubicTo(c1x, c1y, c2x, c2y, x, y) => {
                // Flatten cubic bezier to line segments
                let steps = 8;
                for i in 0..steps {
                    let t0 = i as f32 / steps as f32;
                    let t1 = (i + 1) as f32 / steps as f32;

                    let p0 = eval_cubic(current.0, current.1, *c1x, *c1y, *c2x, *c2y, *x, *y, t0);
                    let p1 = eval_cubic(current.0, current.1, *c1x, *c1y, *c2x, *c2y, *x, *y, t1);
                    lines.push((p0, p1));
                }
                current = (*x, *y);
            }
            PathSegment::Close => {
                if current != path_start {
                    lines.push((current, path_start));
                }
                current = path_start;
            }
        }
    }

    lines
}

fn eval_quad(x0: f32, y0: f32, cx: f32, cy: f32, x1: f32, y1: f32, t: f32) -> (f32, f32) {
    let mt = 1.0 - t;
    let x = mt * mt * x0 + 2.0 * mt * t * cx + t * t * x1;
    let y = mt * mt * y0 + 2.0 * mt * t * cy + t * t * y1;
    (x, y)
}

fn eval_cubic(x0: f32, y0: f32, c1x: f32, c1y: f32, c2x: f32, c2y: f32, x1: f32, y1: f32, t: f32) -> (f32, f32) {
    let mt = 1.0 - t;
    let x = mt*mt*mt*x0 + 3.0*mt*mt*t*c1x + 3.0*mt*t*t*c2x + t*t*t*x1;
    let y = mt*mt*mt*y0 + 3.0*mt*mt*t*c1y + 3.0*mt*t*t*c2y + t*t*t*y1;
    (x, y)
}

fn distance_to_line_segment(px: f32, py: f32, x1: f32, y1: f32, x2: f32, y2: f32) -> f32 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    let len_sq = dx * dx + dy * dy;

    if len_sq < 1e-10 {
        // Degenerate line segment
        return ((px - x1).powi(2) + (py - y1).powi(2)).sqrt();
    }

    // Project point onto line, clamp to segment
    let t = ((px - x1) * dx + (py - y1) * dy) / len_sq;
    let t = t.clamp(0.0, 1.0);

    let closest_x = x1 + t * dx;
    let closest_y = y1 + t * dy;

    ((px - closest_x).powi(2) + (py - closest_y).powi(2)).sqrt()
}

fn compute_winding_number(px: f32, py: f32, lines: &[((f32, f32), (f32, f32))]) -> i32 {
    let mut winding = 0;

    for &((x1, y1), (x2, y2)) in lines {
        if y1 <= py {
            if y2 > py {
                // Upward crossing
                let cross = (x2 - x1) * (py - y1) - (px - x1) * (y2 - y1);
                if cross > 0.0 {
                    winding += 1;
                }
            }
        } else if y2 <= py {
            // Downward crossing
            let cross = (x2 - x1) * (py - y1) - (px - x1) * (y2 - y1);
            if cross < 0.0 {
                winding -= 1;
            }
        }
    }

    winding
}

fn save_debug_pgm(data: &[u8], width: u32, height: u32) {
    let path = "sdf_atlas_debug.pgm";
    let mut file = File::create(path).expect("Failed to create debug file");

    writeln!(file, "P5").unwrap();
    writeln!(file, "{} {}", width, height).unwrap();
    writeln!(file, "255").unwrap();
    file.write_all(data).unwrap();

    println!("  Debug image: {} (open with image viewer)", path);
}
